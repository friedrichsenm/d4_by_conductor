def square_residue(elem, ideal):
    """
    Checks if `elem` is a square residue class of the quotient ring generated
    by the specified ideal.
    """
    if elem.parent() != ZZ:
        elem = ideal.reduce(elem)
        if elem.is_zero():
            return True

        for res in ideal.residues():
            if ideal.reduce(res^2) == elem:
                return True

        return False
    else:
        elem = elem % ideal
        if elem == 0:
            return True

        for i in range(ideal):
            if i^2 % ideal == elem:
                return True

        return False


def squarefree_residue(elem, ideal):
    """
    Checks if the residue class of `elem` in the quotient ring generated by the
    specified ideal possibly contains any representatives that have a squarefree
    ideal factorization.
    """
    ideal_factors = ideal.factor()
    ideal_contains_square_factors = False
    for fctr in ideal_factors:
        if fctr[1] > 1:
            ideal_contains_square_factors = True
            break

    if not ideal_contains_square_factors:
        return True

    if elem.is_zero():
        return False

    if elem.parent() == ZZ:
        elem_factors = elem.factor()
    else:
        elem_factors = elem.parent().ideal(elem).factor()
    for elem_fctr in elem_factors:
        for fctr in ideal_factors:
            if fctr[1] == 1:
                continue
            if elem_fctr[0] == fctr[0] and elem_fctr[1] > 1:
                return False

    return True


def factor_mult(ideal):
    """
    Sums the powers of the prime ideal factors of `ideal`.
    """
    sum = 0
    for fctr in ideal.factor():
        sum += fctr[1]
    return sum


def ideals_dividing(ideal):
    """
    Returns a list of all integral ideals dividing `ideal` ordered by ideals
    with the largest sum of powers of prime ideal factors first.
    """
    factors = ideal.factor()
    if type(ideal) == Integer:
        ideal_list = [1]
    else:
        ideal_list = [ideal.number_field().ideal(1)]
    for fctr in factors:
        temp_lis = deepcopy(ideal_list)
        for i in range(fctr[1]):
            for idl in temp_lis:
                ideal_list.append(idl * (fctr[0]^(i+1)))

    ideal_list.sort(key=factor_mult, reverse=True)
    return ideal_list


def two_part_disc(elem):
    """
    Computes the 2-part of the relative discriminant ideal of
    `K(\\sqrt{elem})/K` using a theorem of Cohen--Diaz-y-Diaz--Olivier.
    """
    parent_ring = elem.parent()
    if parent_ring == ZZ:
        two = 2
        if elem%4 == 0:
            elem = elem//4
        elem_ideal = elem
    else:
        elem_ideal = parent_ring.ideal(elem)
        two = parent_ring.ideal(2)

    if not squarefree_residue(elem, two^2):
        return None

    two_part = two^2

    two_divs = ideals_dividing(two)

    for fctr in elem_ideal.factor():
        if fctr[0].divides(two):
            two_part *= fctr[0]
            two_divs = list(filter(lambda x: not fctr[0].divides(x), two_divs))

    for idl in two_divs:
        if square_residue(elem, idl^2):
            return two_part/(idl^2)


def local_quad_reps(K):
    """
    Given a number field `K`, computes the global representatives of
    `K_p^{x}/K_p^{x2}` for each `p|2` and combines them using CRT to get a
    complete list for every combination of isomorphism classes.
    """
    rep_list = []
    cumulative_ideal = K.ideal(1)
    for p, e in K.ideal(2).factor():
        pi = K.uniformizer(p)
        p_rep_list = []
        p_squares = []
        temp_id = p^(2*e+1)
        p_elem_list = [temp_id.reduce(elem) for elem in temp_id.invertible_residues()]
        for i in range(len(p_elem_list)):
            p_elem_list[i] = temp_id.reduce(p_elem_list[i])
            if temp_id.reduce(p_elem_list[i]^2) not in p_squares:
                p_squares.append(temp_id.reduce(p_elem_list[i]^2))

        for p_elem in p_elem_list:
            for square in p_squares:
                if temp_id.reduce(p_elem * square) in p_rep_list:
                    break
            else:
                p_rep_list.append(p_elem)
                p_rep_list.append((temp_id*p).reduce(pi * p_elem))

        if len(rep_list) == 0:
            rep_list = p_rep_list
        else:
            temp_list = []
            for r_elem in rep_list:
                for p_elem in p_rep_list:
                    temp_list.append(
                        (cumulative_ideal * temp_id*p).reduce(
                            K.solve_CRT([r_elem, p_elem], [cumulative_ideal, temp_id*p])
                         )
                    )
            rep_list = temp_list
        cumulative_ideal *= temp_id * p

    return rep_list


for i in [2, -2, 5, -5, 10, -10, -1, -7]:
    K = QuadraticField(i)
    D_K = gcd(8,abs(K.discriminant()))
    if i == -7: # 2 splits in K(\sqrt(-7))
        aut_weight = 4
    else:
        aut_weight = 2
    D_L_K_rows = [
        ['D_2(L/K) = 2^0',0,0,0],
        ['2^2',0,0,0],
        ['2^3',0,0,0],
        ['2^4',0,0,0],
        ['2^5',0,0,0],
        ['2^6',0,0,0]
    ]
    for rep in local_quad_reps(K):
        relative_disc_2 = two_part_disc(rep)
        if relative_disc_2.norm() == 1:
            two_power = 0
        else:
            two_power = relative_disc_2.norm().factor()[0][1]
        flipped_disc_2 = two_part_disc(rep.norm()%16)
        if flipped_disc_2.norm() == 1:
            flipped_two_power = 0
        else:
            flipped_two_power = flipped_disc_2.norm().factor()[0][1]

        if two_power == 0:
            row_index = 0
        else:
            row_index = two_power - 1
        if flipped_two_power == 0:
            col_index = 1
        else:
            col_index = flipped_two_power

        D_L_K_rows[row_index][col_index] += \
            1/(2*aut_weight * D_K*relative_disc_2.norm())

    remove_rows = []
    for x in range(6):
        if D_L_K_rows[x][1] == 0 and D_L_K_rows[x][2] == 0 \
            and D_L_K_rows[x][3] == 0:
            remove_rows.append(x)

    remove_rows.reverse()
    for x in remove_rows:
        out = D_L_K_rows.pop(x)

    print(K)
    print(table(
        D_L_K_rows,
        header_row=['', 'D_2(\\Phi(K)) = 2^0', '2^2', '2^3'],
        frame=True
    ))
    print()
